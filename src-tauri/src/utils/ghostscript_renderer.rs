use anyhow::{Context, Result};
use std::fs;
use std::process::Command;
use std::thread;
use std::time::Duration;
use std::sync::Arc;
use std::sync::atomic::{AtomicU32, Ordering};
use tempfile::TempDir;
use tauri::{AppHandle, Emitter};
use crate::models::ConversionProgress;

/// Convert PDF to images using Ghostscript with progress tracking
pub fn convert_pdf_with_ghostscript_progress(
    pdf_data: &[u8],
    total_pages: u32,
    dpi: u32,
    quality: u8,
    app: Option<AppHandle>,
) -> Result<(Vec<(String, Vec<u8>)>, Arc<AtomicU32>)> {
    eprintln!("[GS] Starting Ghostscript conversion at {} DPI, quality {} ({} pages expected)", dpi, quality, total_pages);

    // Create temp directory for output
    let temp_dir = TempDir::new().context("Failed to create temp directory")?;
    let temp_path = temp_dir.path();

    // Write PDF to temp file
    let pdf_path = temp_path.join("input.pdf");
    fs::write(&pdf_path, pdf_data).context("Failed to write PDF to temp file")?;

    // Prepare output template
    let output_template = temp_path.join("page_%d.jpg");
    let output_template_str = output_template.to_str().context("Invalid temp path")?;

    eprintln!("[GS] Temp directory: {}", temp_path.display());

    // Shared atomic counter for progress tracking
    let pages_rendered = Arc::new(AtomicU32::new(0));
    let pages_rendered_clone = pages_rendered.clone();

    // Spawn a thread to monitor progress
    let temp_path_clone = temp_path.to_path_buf();
    let app_clone = app.clone();
    let progress_handle = std::thread::spawn(move || {
        let mut last_count = 0;
        loop {
            // Count generated pages
            let mut count = 0;
            for i in 1..=total_pages {
                let page_file = temp_path_clone.join(format!("page_{}.jpg", i));
                if page_file.exists() {
                    count += 1;
                } else {
                    break;
                }
            }

            if count > last_count {
                pages_rendered_clone.store(count, Ordering::Relaxed);
                eprintln!("[GS] Progress: {}/{} pages", count, total_pages);
                
                // Emit progress to frontend
                if let Some(ref app_handle) = app_clone {
                    let percentage = (count as f32 / total_pages as f32) * 100.0;
                    let progress = ConversionProgress {
                        current_page: count,
                        total_pages,
                        percentage,
                        status: "processing".to_string(),
                        message: Some(format!("Rendering {}/{} pages ({:.0}%)", count, total_pages, percentage)),
                    };
                    let _ = app_handle.emit("conversion-progress", &progress);
                }
                
                last_count = count;
            }

            if count >= total_pages {
                break;
            }

            thread::sleep(Duration::from_millis(100)); // Update more frequently
        }
    });

    // Call Ghostscript
    let status = Command::new("gs")
        .args(&[
            "-sDEVICE=jpeg",
            &format!("-r{}x{}", dpi, dpi),
            &format!("-dJPEGQ={}", quality),
            "-q",
            "-dNOPAUSE",
            "-dBATCH",
            &format!("-sOutputFile={}", output_template_str),
            pdf_path.to_str().context("Invalid PDF path")?,
        ])
        .status()
        .context("Failed to execute Ghostscript")?;

    if !status.success() {
        return Err(anyhow::anyhow!("Ghostscript conversion failed with status: {}", status));
    }

    eprintln!("[GS] Ghostscript conversion completed successfully");

    // Wait for progress monitor to finish
    let _ = progress_handle.join();

    // Collect output images
    let mut results = Vec::new();
    let mut page_num = 1;

    loop {
        let page_file = temp_path.join(format!("page_{}.jpg", page_num));

        if !page_file.exists() {
            break;
        }

        let image_data = fs::read(&page_file)
            .context(format!("Failed to read page {}", page_num))?;

        let filename = format!("page_{:04}.jpg", page_num);
        results.push((filename, image_data));

        eprintln!("[GS] Loaded page {}: {} bytes", page_num, results.last().unwrap().1.len());
        page_num += 1;
    }

    if results.is_empty() {
        return Err(anyhow::anyhow!("No pages were generated by Ghostscript"));
    }

    eprintln!("[GS] Total pages generated: {}", results.len());
    Ok((results, pages_rendered))
}

/// Convert PDF to images using Ghostscript (legacy without progress)
pub fn convert_pdf_with_ghostscript(
    pdf_data: &[u8],
    dpi: u32,
    quality: u8,
) -> Result<Vec<(String, Vec<u8>)>> {
    eprintln!("[GS] Starting Ghostscript conversion at {} DPI, quality {}", dpi, quality);

    // Create temp directory for output
    let temp_dir = TempDir::new().context("Failed to create temp directory")?;
    let temp_path = temp_dir.path();

    // Write PDF to temp file
    let pdf_path = temp_path.join("input.pdf");
    fs::write(&pdf_path, pdf_data).context("Failed to write PDF to temp file")?;

    // Prepare output template
    let output_template = temp_path.join("page_%d.jpg");
    let output_template_str = output_template.to_str().context("Invalid temp path")?;

    eprintln!("[GS] Temp directory: {}", temp_path.display());

    // Call Ghostscript
    let status = Command::new("gs")
        .args(&[
            "-sDEVICE=jpeg",
            &format!("-r{}x{}", dpi, dpi),
            &format!("-dJPEGQ={}", quality),
            "-q",
            "-dNOPAUSE",
            "-dBATCH",
            &format!("-sOutputFile={}", output_template_str),
            pdf_path.to_str().context("Invalid PDF path")?,
        ])
        .status()
        .context("Failed to execute Ghostscript")?;

    if !status.success() {
        return Err(anyhow::anyhow!("Ghostscript conversion failed with status: {}", status));
    }

    eprintln!("[GS] Ghostscript conversion completed successfully");

    // Collect output images
    let mut results = Vec::new();
    let mut page_num = 1;

    loop {
        let page_file = temp_path.join(format!("page_{}.jpg", page_num));

        if !page_file.exists() {
            break;
        }

        let image_data = fs::read(&page_file)
            .context(format!("Failed to read page {}", page_num))?;

        let filename = format!("page_{:04}.jpg", page_num);
        results.push((filename, image_data));

        eprintln!("[GS] Loaded page {}: {} bytes", page_num, results.last().unwrap().1.len());
        page_num += 1;
    }

    if results.is_empty() {
        return Err(anyhow::anyhow!("No pages were generated by Ghostscript"));
    }

    eprintln!("[GS] Total pages generated: {}", results.len());
    Ok(results)
}

/// Check if Ghostscript is available
pub fn is_ghostscript_available() -> bool {
    Command::new("gs")
        .arg("--version")
        .output()
        .map(|output| output.status.success())
        .unwrap_or(false)
}
